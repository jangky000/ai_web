<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
<link href="../../css/style.css" rel='Stylesheet' type='text/css'>
</head>
<body>
  <script type="text/javascript">
    function wl(str) {
      document.writeln(str + '<br>'); // BODY 태그로 출력됨.
    }
  
    // 정규 표현식
    function comma(su) {
      return su.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    
    // class
    // 함수, 생성자, 클래스 모양이 모두 같다
    // 하나의 파일에 여러 개의 클래스를 선언할 수 있다. 
    function Web(){
      // 필드
      this.name = 'Web 개발';
      this.skill = 'Java, Spring, Oracle';
      
      //지역변수
      var area = '서울';
    }
    
   var web = new Web();
   wl(web.name);   // Web 개발
   wl(web.skill);    // Java, Spring, Oracle
   wl(web.area);   // undefined, 지역변수는 객체변수로 접근할 수 없음
   
   wl('-------------------');
   
   // class 선언과 동시에 객체 생성
   // 키와 값의 구조
   var dev = {
      // 필드
      // 'this.' 삭제 /  '=' 대신 ':' 사용 /  끝에 ';' 사용하면 안됨
      name:'Web 개발', 
      skill:'Java, Spring, Oracle',
      area:'서울',
      getFirstDay: (yy, mm, dd) => new Date(yy, mm, dd)
    }; // ; 사용하는 것이 표준 문법
    
   wl(dev.name); // Web 개발
   wl(dev.skill); // Java, Spring, Oracle
   wl(dev.area); // 서울
   wl(dev.getFirstDay(2020, 05-1, 18)); // 5월 첫째날 요일, 달, 날짜, 연도, 시간
   
   wl('--------------------------');
   // 필드와 함수의 선언, 객체 생성의 분리
   function Academy1() {
     // 필드
     // 전역변수
     this.name = '';
     this.jsp = 0;
     this.js = 0;
     
     // 메소드
     // 변수처럼 선언
     this.setData = function(name, jsp, js) { // 필드 값 저장
       this.name = name;
       this.jsp = jsp;
       this.js = js;
     }
     this.print = function() {
       wl(this.name);
       wl(this.jsp);
       wl(this.js);
       wl('총점: '+ this.tot);
       wl('평균: '+ this.avg);
     };
     this.tot = function() { this.tot = this.jsp + this.js; };
     this.avg = function() { this.avg = this.tot / 2; }; // ; 생략 가능하지만 쓰는 것이 표준
     
   }
   
   var academy1 = new Academy1();
   academy1.setData('왕눈이', 90, 85);
   academy1.tot();
   academy1.avg();
   academy1.print();
   
   // OOP의 중요한 이론, 개념
   // 객체 지향에서 
   // 객체는 필드만 새롭게 메모리 할당하고, 메소드는 반복해서 생성할 필요가 없다.
   // (메모리 효율을 위해서 메소드는 공유하여 빌려 쓴다)
   // 자바에서 객체의 해시코드, this의 해시코드가 같다.
   
   // 하지만 자바스크립트에서는 객체 생성시 
   // 함수들이 반복해서 생성됨, 공유하지 않음
   var academy2 = new Academy1();
   var academy3 = new Academy1();
   
   
   wl('--------------------------');
   // 개선
   // 메모리를 적게 쓰는 우수한 모델
   // prototype의 사용, (함수 공유)
   function AcademyPro() {
     // 필드
     // 전역변수
     this.name = '';
     this.jsp = 0;
     this.js = 0;
     
     // prototype 메소드
     //클래스.prototype.메소드명
     AcademyPro.prototype.setData = function(name, jsp, js) { // 필드 값 저장
       this.name = name;
       this.jsp = jsp;
       this.js = js;
     }
     AcademyPro.prototype.print = function() {
       wl(this.name);
       wl(this.jsp);
       wl(this.js);
       wl('총점: '+ this.tot);
       wl('평균: '+ this.avg);
     };
     AcademyPro.prototype.tot = function() { this.tot = this.jsp + this.js; };
     AcademyPro.prototype.avg = function() { this.avg = this.tot / 2; }; // ; 생략 가능하지만 쓰는 것이 표준
   }
   
   var academypro1 = new AcademyPro();
   academypro1.setData('아로미', 95, 100);
   academypro1.tot();
   academypro1.avg();
   academypro1.print();

   // 객체 생성시 함수들을 공유
   var academypro2 = new AcademyPro(); // 공유된 함수 사용
   var academypro3 = new AcademyPro(); // 공유된 함수 사용
   
   // 메모리 주소를 찍을 수는 없다..
  </script>
</body>
</html>